(ns diceware.core
  (:require [reagent.core :as reagent]
            [cljsjs.react]
            [diceware.generators :as dg])
  (:use [clojure.string :only [split-lines]]))

(enable-console-print!)

;; Require the node filesystem module to read the diceware word file.
(def fs (js/require "fs"))

(defn read-diceware-words-file []
  (let [text (.readFileSync fs "./app/diceware8k.txt" {:encoding "utf-8"})]
    (clojure.string/split-lines text)))

(def generators-view {:passphrase {:name "Passphrase"}
                      :password-outlook {:name "Password (Outlook)"}
                      :password-windows {:name "Password (Windows)"}
                      :password {:name "Password"}
                      :pin {:name "PIN (5-digit)"}})

(def app-state
  (reagent/atom
    ;; The "as-is" and "to-be" values begin as **copies** of each other (not shared).
    {:options {:as-is {:generator :passphrase
                       :count 5}
               :to-be {:generator :passphrase
                       :count 5}}
     :results {:candidates []}}))

(defn get-how-many [which]
  (get-in @app-state [:options which :count]))

(defn copy-options-to-be->as-is! []
 (swap! app-state update-in [:options :as-is] merge (get-in @app-state [:options :to-be])))

;; I changed `view-generator-selector` to dereference `app-state`. When I made this change, the Electron developer tools
;; then reported a warning:
;;
;; Warning: Reactive deref not support in lazy seq, it should be wrapped in doall (in diceware.core.main_page)...
;;
;; The warning then refers to the radio button elements generated by `view-generator-selector`. This warning is
;; described on the web page: https://github.com/reagent-project/reagent/issues/18.
;;
;; After examining the code, I realized that `view-generator-selected` **did not** generate a `seq`. Examining the
;; call stack, I eventually realized that `view-generators` invoked `map` which **does** generate a `seq`.
;;
;; The warning and the issue suggested wrapping the `seq` in `doall`. This wrapping resolved the issue.
;;
(defn view-generator-selector [generator-id]
  (let [generator-id-text (name generator-id)]
    [:div
     [:input {:type "radio" :name "generator" :id generator-id-text
              :checked (= generator-id (get-in @app-state [:options :to-be :generator]))
              :on-change (fn [e] (swap! app-state update-in [:options :to-be :generator]
                                        (fn [_old] (-> e .-target .-id keyword))))}]
     [:label {:for generator-id-text :class "radio-label"} (get-in generators-view [generator-id :name])]]))

(defn view-generators []
  (doall (map #(with-meta (view-generator-selector %) {:key %}) (keys generators-view))))

(defn view-how-many []
  [:div {:class-name "how-many vertical-isolation"}
    [:label {:for "count" :class "text-label"} "How Many?"]
    [:input {:type "number" :name "count" :id "count" :value (get-how-many :to-be) :min 1 :max 17
             :on-change (fn [e] (swap! app-state update-in [:options :to-be :count]
                                       (fn [_old] (-> e .-target .-value js/parseInt))))}]])

(defn options []
  [:section {:id "options" :class-name "col-4"}
   [:h2 "Options"]
   [:form
    (view-generators)
    (view-how-many)
    [:input {:type "submit" :class-name "span-width vertical-isolation" :value "Go!" :id "go"
             :on-click
                   (fn [ev]
                     (.preventDefault ev)
                     (copy-options-to-be->as-is!)
                     (let [source-words (read-diceware-words-file)]
                       (swap! app-state update-in [:results :candidates]
                              (fn [_old] (dg/generate (get-in @app-state [:options :to-be :generator])
                                                      (get-how-many :to-be)
                                                      source-words
                                                      (partial rand-nth))))))}]]])


(defn view-candidate-passwords []
  [:ul
   (let [candidate-passwords (get-in @app-state [:results :candidates])]
    (if (not (empty? candidate-passwords))
                    (map-indexed (fn [i pwd] ^{:key i} [:li pwd]) candidate-passwords)
                    (map-indexed (fn [i _] ^{:key i} [:li]) (range (get-how-many :as-is)))))])

(defn results []
  [:section {:id "results" :class-name "col-8"}
   [:section {:class-name "generated"}
    [:h2 "Generated"]
    (view-candidate-passwords)]
   [:section {:class-name "practice"}
    [:h2 "Practice"]
    [:textarea {:rows (get-how-many :as-is)
                :cols 55}]]])

(defn main-page
  []
  [:header
   [:h1 "Password Generator"]
   [:section {:class-name "row"}
    (options)
    (results)
    ]])

(defn mount-root
  []
  (reagent/render [main-page] (.getElementById js/document "app")))

(defn init!
  []
  (mount-root))
